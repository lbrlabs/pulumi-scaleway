// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface BaremetalServerIp {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface DatabaseAclAclRule {
    description: string;
    ip: string;
}

export interface DatabaseInstanceLoadBalancer {
    endpointId: string;
    hostname: string;
    ip: string;
    name: string;
    port: number;
}

export interface DatabaseInstancePrivateNetwork {
    endpointId: string;
    hostname: string;
    ip: string;
    ipNet: string;
    name: string;
    pnId: string;
    port: number;
    zone: string;
}

export interface DatabaseInstanceReadReplica {
    ip: string;
    name: string;
    port: number;
}

export interface DomainRecordGeoIp {
    matches: outputs.DomainRecordGeoIpMatch[];
}

export interface DomainRecordGeoIpMatch {
    continents?: string[];
    countries?: string[];
    data: string;
}

export interface DomainRecordHttpService {
    ips: string[];
    mustContain: string;
    strategy: string;
    url: string;
    userAgent?: string;
}

export interface DomainRecordView {
    data: string;
    subnet: string;
}

export interface DomainRecordWeighted {
    ip: string;
    weight: number;
}

export interface GetBaremetalOfferCpu {
    coreCount: number;
    frequency: number;
    name: string;
    threadCount: number;
}

export interface GetBaremetalOfferDisk {
    capacity: number;
    type: string;
}

export interface GetBaremetalOfferMemory {
    capacity: number;
    frequency: number;
    isEcc: boolean;
    type: string;
}

export interface GetBaremetalServerIp {
    address: string;
    id: string;
    reverse: string;
    version: string;
}

export interface GetDatabaseAclAclRule {
    description: string;
    ip: string;
}

export interface GetDatabaseInstanceLoadBalancer {
    endpointId: string;
    hostname: string;
    ip: string;
    name: string;
    port: number;
}

export interface GetDatabaseInstancePrivateNetwork {
    endpointId: string;
    hostname: string;
    ip: string;
    ipNet: string;
    name: string;
    pnId: string;
    port: number;
    zone: string;
}

export interface GetDatabaseInstanceReadReplica {
    ip: string;
    name: string;
    port: number;
}

export interface GetDomainRecordGeoIp {
    matches: outputs.GetDomainRecordGeoIpMatch[];
}

export interface GetDomainRecordGeoIpMatch {
    continents: string[];
    countries: string[];
    data: string;
}

export interface GetDomainRecordHttpService {
    ips: string[];
    mustContain: string;
    strategy: string;
    url: string;
    userAgent: string;
}

export interface GetDomainRecordView {
    data: string;
    subnet: string;
}

export interface GetDomainRecordWeighted {
    ip: string;
    weight: number;
}

export interface GetInstanceSecurityGroupInboundRule {
    action: string;
    ip: string;
    ipRange: string;
    port: number;
    portRange: string;
    protocol: string;
}

export interface GetInstanceSecurityGroupOutboundRule {
    action: string;
    ip: string;
    ipRange: string;
    port: number;
    portRange: string;
    protocol: string;
}

export interface GetInstanceServerPrivateNetwork {
    macAddress: string;
    pnId: string;
    status: string;
    zone: string;
}

export interface GetInstanceServerRootVolume {
    boot: boolean;
    deleteOnTermination: boolean;
    sizeInGb: number;
    volumeId: string;
    volumeType: string;
}

export interface GetIotDeviceCertificate {
    crt: string;
    key: string;
}

export interface GetIotDeviceMessageFilter {
    publishes: outputs.GetIotDeviceMessageFilterPublish[];
    subscribes: outputs.GetIotDeviceMessageFilterSubscribe[];
}

export interface GetIotDeviceMessageFilterPublish {
    policy: string;
    topics: string[];
}

export interface GetIotDeviceMessageFilterSubscribe {
    policy: string;
    topics: string[];
}

export interface GetKubernetesClusterAutoUpgrade {
    enable: boolean;
    maintenanceWindowDay: string;
    maintenanceWindowStartHour: number;
}

export interface GetKubernetesClusterAutoscalerConfig {
    balanceSimilarNodeGroups: boolean;
    disableScaleDown: boolean;
    estimator: string;
    expander: string;
    expendablePodsPriorityCutoff: number;
    ignoreDaemonsetsUtilization: boolean;
    maxGracefulTerminationSec: number;
    scaleDownDelayAfterAdd: string;
    scaleDownUnneededTime: string;
    scaleDownUtilizationThreshold: number;
}

export interface GetKubernetesClusterKubeconfig {
    clusterCaCertificate: string;
    configFile: string;
    host: string;
    token: string;
}

export interface GetKubernetesClusterOpenIdConnectConfig {
    clientId: string;
    groupsClaims: string[];
    groupsPrefix: string;
    issuerUrl: string;
    requiredClaims: string[];
    usernameClaim: string;
    usernamePrefix: string;
}

export interface GetKubernetesNodePoolNode {
    name: string;
    publicIp: string;
    publicIpV6: string;
    status: string;
}

export interface GetKubernetesNodePoolUpgradePolicy {
    maxSurge: number;
    maxUnavailable: number;
}

export interface GetLoadbalancerCertificateCustomCertificate {
    certificateChain: string;
}

export interface GetLoadbalancerCertificateLetsencrypt {
    commonName: string;
    subjectAlternativeNames: string[];
}

export interface GetLoadbalancerPrivateNetwork {
    dhcpConfig: boolean;
    privateNetworkId: string;
    staticConfigs: string[];
    status: string;
    zone: string;
}

export interface GetObjectBucketCorsRule {
    allowedHeaders: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders: string[];
    maxAgeSeconds: number;
}

export interface GetObjectBucketLifecycleRule {
    abortIncompleteMultipartUploadDays: number;
    enabled: boolean;
    expirations: outputs.GetObjectBucketLifecycleRuleExpiration[];
    id: string;
    prefix: string;
    tags: {[key: string]: string};
    transitions: outputs.GetObjectBucketLifecycleRuleTransition[];
}

export interface GetObjectBucketLifecycleRuleExpiration {
    days: number;
}

export interface GetObjectBucketLifecycleRuleTransition {
    days: number;
    storageClass: string;
}

export interface GetObjectBucketVersioning {
    enabled: boolean;
}

export interface GetRedisClusterAcl {
    description: string;
    id: string;
    ip: string;
}

export interface InstanceSecurityGroupInboundRule {
    action: string;
    ip?: string;
    ipRange?: string;
    port?: number;
    portRange?: string;
    protocol?: string;
}

export interface InstanceSecurityGroupOutboundRule {
    action: string;
    ip?: string;
    ipRange?: string;
    port?: number;
    portRange?: string;
    protocol?: string;
}

export interface InstanceSecurityGroupRulesInboundRule {
    action: string;
    ip?: string;
    ipRange?: string;
    port?: number;
    portRange?: string;
    protocol?: string;
}

export interface InstanceSecurityGroupRulesOutboundRule {
    action: string;
    ip?: string;
    ipRange?: string;
    port?: number;
    portRange?: string;
    protocol?: string;
}

export interface InstanceServerPrivateNetwork {
    macAddress: string;
    pnId: string;
    status: string;
    zone: string;
}

export interface InstanceServerRootVolume {
    boot?: boolean;
    deleteOnTermination?: boolean;
    sizeInGb: number;
    volumeId: string;
    volumeType: string;
}

export interface IotDeviceCertificate {
    crt: string;
    key: string;
}

export interface IotDeviceMessageFilters {
    publish?: outputs.IotDeviceMessageFiltersPublish;
    subscribe?: outputs.IotDeviceMessageFiltersSubscribe;
}

export interface IotDeviceMessageFiltersPublish {
    policy?: string;
    topics?: string[];
}

export interface IotDeviceMessageFiltersSubscribe {
    policy?: string;
    topics?: string[];
}

export interface IotRouteDatabase {
    dbname: string;
    host: string;
    password: string;
    port: number;
    query: string;
    username: string;
}

export interface IotRouteRest {
    headers: {[key: string]: string};
    uri: string;
    verb: string;
}

export interface IotRouteS3 {
    bucketName: string;
    bucketRegion: string;
    objectPrefix?: string;
    strategy: string;
}

export interface KubernetesClusterAutoUpgrade {
    enable: boolean;
    maintenanceWindowDay: string;
    maintenanceWindowStartHour: number;
}

export interface KubernetesClusterAutoscalerConfig {
    balanceSimilarNodeGroups?: boolean;
    disableScaleDown?: boolean;
    estimator?: string;
    expander?: string;
    expendablePodsPriorityCutoff?: number;
    ignoreDaemonsetsUtilization?: boolean;
    maxGracefulTerminationSec?: number;
    scaleDownDelayAfterAdd?: string;
    scaleDownUnneededTime?: string;
    scaleDownUtilizationThreshold?: number;
}

export interface KubernetesClusterKubeconfig {
    clusterCaCertificate: string;
    configFile: string;
    host: string;
    token: string;
}

export interface KubernetesClusterOpenIdConnectConfig {
    clientId: string;
    groupsClaims?: string[];
    groupsPrefix?: string;
    issuerUrl: string;
    requiredClaims?: string[];
    usernameClaim?: string;
    usernamePrefix?: string;
}

export interface KubernetesNodePoolNode {
    name: string;
    publicIp: string;
    publicIpV6: string;
    status: string;
}

export interface KubernetesNodePoolUpgradePolicy {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface LoadbalancerBackendHealthCheckHttp {
    code?: number;
    method?: string;
    uri: string;
}

export interface LoadbalancerBackendHealthCheckHttps {
    code?: number;
    method?: string;
    uri: string;
}

export interface LoadbalancerBackendHealthCheckTcp {
}

export interface LoadbalancerCertificateCustomCertificate {
    certificateChain: string;
}

export interface LoadbalancerCertificateLetsencrypt {
    commonName: string;
    subjectAlternativeNames?: string[];
}

export interface LoadbalancerFrontendAcl {
    action: outputs.LoadbalancerFrontendAclAction;
    match: outputs.LoadbalancerFrontendAclMatch;
    name: string;
}

export interface LoadbalancerFrontendAclAction {
    type: string;
}

export interface LoadbalancerFrontendAclMatch {
    httpFilter?: string;
    httpFilterOption?: string;
    httpFilterValues?: string[];
    invert?: boolean;
    ipSubnets?: string[];
}

export interface LoadbalancerPrivateNetwork {
    dhcpConfig?: boolean;
    privateNetworkId: string;
    staticConfigs?: string[];
    status: string;
    zone: string;
}

export interface ObjectBucketCorsRule {
    allowedHeaders?: string[];
    allowedMethods: string[];
    allowedOrigins: string[];
    exposeHeaders?: string[];
    maxAgeSeconds?: number;
}

export interface ObjectBucketLifecycleRule {
    abortIncompleteMultipartUploadDays?: number;
    enabled: boolean;
    expiration?: outputs.ObjectBucketLifecycleRuleExpiration;
    id: string;
    prefix?: string;
    tags?: {[key: string]: string};
    transitions?: outputs.ObjectBucketLifecycleRuleTransition[];
}

export interface ObjectBucketLifecycleRuleExpiration {
    days: number;
}

export interface ObjectBucketLifecycleRuleTransition {
    days?: number;
    storageClass: string;
}

export interface ObjectBucketVersioning {
    enabled?: boolean;
}

export interface RedisClusterAcl {
    description: string;
    id: string;
    ip: string;
}

